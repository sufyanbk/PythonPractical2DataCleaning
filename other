-- ================================================================
-- CHANNEL × HOUR (0–23) MATRIX — aggregated across all days
-- Creates a readable dataset for dashboards/CSV: one row per
-- Channel and Hour-of-day with alerts, intersections, and fraud.
-- ================================================================

CREATE OR REPLACE VIEW `PROJECT.DATASET.channel_hourly_matrix` AS
WITH
  -- 0..23 hour spine to ensure every hour appears
  hours AS (
    SELECT hour FROM UNNEST(GENERATE_ARRAY(0, 23)) AS hour
  ),

  -- Base rows with clean money and hour extracted from ms-string
  base AS (
    SELECT
      portfolio_key AS channel,
      EXTRACT(HOUR FROM TIMESTAMP_MILLIS(CAST(event_received_at AS INT64))) AS event_hour,
      DSE_ALERT, PROD_ALERT, BOTH_ALERT, DSE_ONLY_ALERT, PROD_ONLY_ALERT,
      FLAG_FRAUD,
      SAFE_CAST(tbt_tran_amt AS NUMERIC) AS amount_gbp
    FROM `PROJECT.DATASET.analysis_rows_alerts`
  ),

  -- Distinct channels to cross with hour spine (ensures 24 rows/channel)
  channels AS (
    SELECT DISTINCT channel FROM base
  ),

  -- Aggregate across ALL days by Channel × Hour
  agg AS (
    SELECT
      channel,
      event_hour,

      -- Alerts
      SUM(DSE_ALERT)  AS dse_alerts,
      SUM(PROD_ALERT) AS prod_alerts,
      SUM(BOTH_ALERT) AS intersect_alerts,     -- = both_alerts
      SUM(DSE_ONLY_ALERT) AS dse_only_alerts,
      SUM(PROD_ONLY_ALERT) AS prod_only_alerts,

      -- Fraud-in-alert (counts)
      SUM(CASE WHEN DSE_ALERT =1 AND FLAG_FRAUD=1 THEN 1 ELSE 0 END) AS dse_fraud_cnt,
      SUM(CASE WHEN PROD_ALERT=1 AND FLAG_FRAUD=1 THEN 1 ELSE 0 END) AS prod_fraud_cnt,
      SUM(CASE WHEN BOTH_ALERT=1 AND FLAG_FRAUD=1 THEN 1 ELSE 0 END) AS intersect_fraud_cnt,

      -- Fraud-in-alert (values, £)
      SUM(CASE WHEN DSE_ALERT =1 AND FLAG_FRAUD=1 THEN amount_gbp ELSE 0 END) AS dse_fraud_val_gbp,
      SUM(CASE WHEN PROD_ALERT=1 AND FLAG_FRAUD=1 THEN amount_gbp ELSE 0 END) AS prod_fraud_val_gbp
    FROM base
    GROUP BY channel, event_hour
  )

-- Final matrix: 24 rows per channel, zeros when no data in that hour
SELECT
  c.channel,
  h.hour AS event_hour,

  -- Alert volumes
  COALESCE(a.dse_alerts, 0)          AS dse_alerts,
  COALESCE(a.prod_alerts, 0)         AS prod_alerts,
  COALESCE(a.intersect_alerts, 0)    AS intersect_alerts,        -- |DSE ∩ PROD|
  COALESCE(a.dse_only_alerts, 0)     AS dse_only_alerts,
  COALESCE(a.prod_only_alerts, 0)    AS prod_only_alerts,

  -- Symmetric intersection % (Jaccard) for alerts
  SAFE_DIVIDE(
    COALESCE(a.intersect_alerts, 0),
    NULLIF(COALESCE(a.dse_alerts, 0) + COALESCE(a.prod_alerts, 0) - COALESCE(a.intersect_alerts, 0), 0)
  ) AS intersect_alert_pct,                                           -- |∩| / |∪|

  -- Fraud (counts)
  COALESCE(a.dse_fraud_cnt, 0)       AS dse_fraud_cnt,
  COALESCE(a.prod_fraud_cnt, 0)      AS prod_fraud_cnt,
  COALESCE(a.intersect_fraud_cnt, 0) AS intersect_fraud_cnt,         -- fraud caught by BOTH

  -- Symmetric intersection % for fraud-in-alert (counts)
  SAFE_DIVIDE(
    COALESCE(a.intersect_fraud_cnt, 0),
    NULLIF(COALESCE(a.dse_fraud_cnt, 0) + COALESCE(a.prod_fraud_cnt, 0) - COALESCE(a.intersect_fraud_cnt, 0), 0)
  ) AS intersect_fraud_pct,                                          -- |∩ fraud| / |∪ fraud|

  -- Fraud (values £)
  COALESCE(a.dse_fraud_val_gbp, 0)   AS dse_fraud_val_gbp,
  COALESCE(a.prod_fraud_val_gbp, 0)  AS prod_fraud_val_gbp

FROM channels c
CROSS JOIN hours h
LEFT JOIN agg a
  ON a.channel = c.channel
 AND a.event_hour = h.hour
ORDER BY c.channel, event_hour;
